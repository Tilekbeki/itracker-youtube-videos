---
created at: 2025-08-19
tags:
  - review
zero-links:
  - 03.01 Вопросы связанные с веб технологиями
sr-due: 2025-09-18
sr-interval: 1
sr-ease: 230
---
Веб-компоненты - это технология, которая позволяет создавать многократно используемые компоненты в веб документах и приложениях, они поддерживаются браузерами напрямую и не требуют библиотек для работы.

- [html templates](https://learn.javascript.ru/template-element)
    
    - Содержимым `<template>` может быть любой синтаксически корректный HTML.
    - Содержимое `<template>` считается находящимся «вне документа», поэтому оно ни на что не влияет.
    - Мы можем получить доступ к `template.content` из JavaScript, клонировать его и переиспользовать в новом компоненте.
    
    Элемент `<template>` уникальный по следующим причинам:
    
    - Браузер проверяет правильность HTML-синтаксиса в нём (в отличие от строк в скриптах).
    - …При этом позволяет использовать любые HTML-теги, даже те, которые без соответствующей обёртки не используются (например `<tr>`).
    - Его содержимое оживает (скрипты выполняются, `<video autoplay>` проигрывается и т. д.), когда помещается в документ.
    
    Элемент `<template>` не поддерживает итерацию, связывания данных или подстановки переменных. Однако эти возможности можно реализовать поверх него.
    
- html import
    
    [**Устарел и removed**](https://chromestatus.com/feature/5144752345317376)
    
    Тег `<link rel="import">` позволяет подключить любой документ к странице, причём:
    
    - Скриптовое пространство и стили со страницей будут общие.
    - Документ DOM – отдельный, он доступен как `link.import` снаружи, а из внутреннего скрипта – через `document.currentScript.ownerDocument`. Можно без проблем переносить элементы из главного документа в импорт и наоборот.
    - Импорты могут содержать другие импорты.
    - Если какой-то URL импортируется повторно – подключается уже готовый документ, без повторного выполнения скриптов в нём. Это позволяет избежать дублирования при использовании одной библиотеки во множестве мест.
- [custom elements](https://learn.javascript.ru/custom-elements)
    
    Есть два типа пользовательских элементов:
    
    1. «Автономные» – новые теги, расширяющие `HTMLElement`.
        
        Схема определения:
        
        ```jsx
        class MyElement extends HTMLElement {
          constructor() {
            super();
            // элемент создан
          }
        
          connectedCallback() {
            // браузер вызывает этот метод при добавлении элемента в документ
            // (может вызываться много раз, если элемент многократно добавляется/удаляется)
          }
        
          disconnectedCallback() {
            // браузер вызывает этот метод при удалении элемента из документа
            // (может вызываться много раз, если элемент многократно добавляется/удаляется)
          }
        
          static get observedAttributes() {
            return [/* массив имён атрибутов для отслеживания их изменений */];
          }
        
          attributeChangedCallback(name, oldValue, newValue) {
            // вызывается при изменении одного из перечисленных выше атрибутов
          }
        
          adoptedCallback() {
            // вызывается, когда элемент перемещается в новый документ
            // (происходит в document.adoptNode, используется очень редко)
          }
        
          // у элемента могут быть ещё другие методы и свойства
        }
        
        // сообщим браузеру, что <my-element> обслуживается нашим новым классом
        customElements.define("my-element", MyElement);
        
        // Теперь для любых HTML-элементов с тегом <my-element>
        // создаётся экземпляр MyElement и вызываются вышеупомянутые методы. 
        // Также мы можем использовать document.createElement('my-element')
        // в JavaScript.
        ```
        
        `connectedCallback` срабатывает, когда элемент добавляется в документ. Не просто добавляется к другому элементу как дочерний, но фактически становится частью страницы. Таким образом, мы можем построить отдельный DOM, создать элементы и подготовить их для последующего использования. Они будут рендериться только тогда, когда попадут на страницу.
        
        Имя пользовательского элемента должно содержать дефис `-`, например, `my-element` и `super-button` – валидные имена, а `myelement` – нет.
        
        Это чтобы гарантировать отсутствие конфликтов имён между встроенными и пользовательскими элементами HTML.
        
    2. «Модифицированные встроенные элементы» – расширения существующих элементов, что обеспечивает понимание тега поисковыми роботами и читалками, но при этом имеющего расширенную функциональность.
        
        Требуют ещё один аргумент в `.define` и атрибут `is="..."` в HTML:
        
        ```jsx
        class MyButton extends HTMLButtonElement { /*...*/ }
        customElements.define('my-button', MyElement, {extends: 'button'});
        /* <button is="my-button"> */
        ```
        
- shadow dom
    
    - [**Shadow DOM**](https://learn.javascript.ru/shadow-dom)
        
        Теневой DOM – это способ создать свой, изолированный, DOM для компонента.
        
        1. `shadowRoot = elem.attachShadow({mode: open|closed})` – создаёт теневой DOM для `elem`. Если `mode="open"`, он доступен через свойство `elem.shadowRoot`.
        2. Мы можем создать подэлементы внутри `shadowRoot` с помощью `innerHTML` или других методов DOM.
        
        Элементы теневого DOM:
        
        - Обладают собственной областью видимости идентификаторов
        - Невидимы JavaScript селекторам из главного документа, таким как `querySelector`,
        - Стилизуются своими стилями из теневого дерева, не из главного документа.
        
        Теневой DOM, если имеется, отрисовывается браузером вместо обычных потомков (light DOM).
        
    - [**Слоты теневого DOM, композиция**](https://learn.javascript.ru/slots-composition)
        
        Обычно, если у элемента есть теневое дерево, то содержимое обычного, светлого DOM не показывается. Слоты позволяют показать элементы светлого DOM на заданных местах в теневом DOM.
        
        Существует два вида слотов:
        
        - Именованные слоты: `<slot name="X">...</slot>` – получают элементы светлого DOM с `slot="X"`.
        - Слот по умолчанию: первый `<slot>` без имени (последующие неименованные слоты игнорируются) – показывает элементы элементов светлого дерева, которые не находятся в других слотах.
        - Если одному слоту назначено несколько элементов, они добавляются один за другим.
        - Содержимое элемента `<slot>` используется как резервное. Оно отображается, если в слоте нет элементов из светлого дерева.
        
        Процесс отображения элементов внутри слота называется «композицией». В результате композиции строится «развёрнутый DOM».
        
        При композиции не происходит перемещения узлов – с точки зрения JavaScript, DOM остаётся прежним.
        
        JavaScript может получить доступ к слотам с помощью следующих методов:
        
        - `slot.assignedNodes/Elements()` – возвращает узлы/элементы, которые находятся внутри `slot`.
        - `node.assignedSlot` – обратный метод, возвращает слот по узлу.
        
        Если мы хотим знать, что показываем, мы можем отследить контент слота следующими способами:
        
        - событие `slotchange` – запускается, когда слот наполняется контентом в первый раз, и при каждой операции добавления/удаления/замещения элемента в слоте, за исключением его потомков. Сам слот будет `event.target`.
        - [MutationObserver](https://learn.javascript.ru/mutation-observer) для более глубокого просмотра содержимого элемента в слоте и отслеживания изменений в нём.
        
        Теперь, когда мы научились показывать элементы светлого DOM в теневом DOM, давайте посмотрим, как их правильно стилизовать. Основное правило звучит так: теневые элементы стилизуются внутри, а обычные элементы – снаружи; однако есть заметные исключения.
        
    - [**Настройка стилей теневого DOM**](https://learn.javascript.ru/shadow-dom-style)
        
        Теневой DOM может включать в себя стили, такие как `<style>` или `<link rel="stylesheet">`.
        
        Локальные стили могут влиять на:
        
        - теневое дерево,
        - элемент-хозяин, при помощи псевдоклассов `:host` и `:host()`,
        - слотовые элементы (из светлого DOM), `::slotted(селектор)` позволяет стилизовать сами слотовые элементы, но не их дочерние элементы.
        
        Стили документов могут влиять на:
        
        - элемент-хозяин (так как он находится во внешнем документе)
        - слотовые элементы и их содержимое (так как они также физически присутствуют во внешнем документе)
        
        Когда свойства CSS конфликтуют, обычно стили документа имеют приоритет, если только свойство не помечено как `!important`. Тогда предпочтение отдаётся локальным стилям.
        
        Пользовательские свойства CSS проникают через теневой DOM. Они используются как «хуки» для придания элементам стиля:
        
        1. Компонент использует пользовательское CSS-свойство для стилизации ключевых элементов, например `var(--component-name-title, <значение по умолчанию>)`.
        2. Автор компонента публикует эти свойства для разработчиков, они так же важны, как и другие общедоступные методы компонента.
        3. Когда разработчик хочет стилизовать заголовок, он назначает CSS-свойство `-component-name-title` для элемента-хозяина или выше.
        4. Profit!
    - [**Теневой DOM и события**](https://learn.javascript.ru/shadow-dom-events)
        
        Только те события пересекают границы теневого DOM, у которых флаг `composed` установлен в значение `true`.
        
        У большинства встроенных событий стоит `composed: true`, это описано в соответствующих спецификациях:
        
        - UI Events [https://www.w3.org/TR/uievents](https://www.w3.org/TR/uievents).
        - Touch Events [https://w3c.github.io/touch-events](https://w3c.github.io/touch-events).
        - Pointer Events [https://www.w3.org/TR/pointerevents](https://www.w3.org/TR/pointerevents).
        - …И так далее.
        
        У некоторых встроенных событий всё же стоит `composed: false`:
        
        - `mouseenter`, `mouseleave` (вообще не всплывают),
        - `load`, `unload`, `abort`, `error`,
        - `select`,
        - `slotchange`.
        
        Эти события могут быть пойманы только на элементах, принадлежащих тому же DOM-дереву. Т.е. оно может быть поймано лишь внутри теневого DOM.
        
        Если мы генерируем своё событие `CustomEvent`, то должны явно поставить флаг `composed: true`.
        
        Обратите внимание, что в случае вложенных компонентов теневые DOM могут быть вложены друг в друга. События с флагом `composed` всплывают через границы всех теневых DOM. Поэтому, если событие предназначено только для ближайшего внешнего компонента-родителя, мы можем инициировать его на элементе-хозяине и установить флаг `composed: false`. Тогда оно будет уже вне теневого DOM компонента, но не выплывает наружу в «ещё более внешний» DOM.